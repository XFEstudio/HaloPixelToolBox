using HaloPixelToolBox.Core.Models;
using System.Text;

namespace HaloPixelToolBox.Core.Utilities;

public class HidPacketBuilder
{
    /// <summary>
    /// 文本头
    /// </summary>
    public static readonly byte[] TextHeader =
    [
        0x2E, 0xAA, 0xEC, 0xE8, 0x00
    ];

    /// <summary>
    /// 布局头
    /// </summary>
    public static readonly byte[] LayoutHeader =
    [
        0x2E, 0xAA, 0xEC, 0xEF, 0x00, 0x09, 0x01, 0xf0, 0xb4, 0xc8, 0x00, 0x02, 0x00
    ];

    /// <summary>
    /// 固定包长度（64 bytes）
    /// </summary>
    private const int FixedPacketLength = 64;

    /// <summary>
    /// 构造 HID 协议包
    /// </summary>
    public static byte[] BuildText(string text)
    {
        if (text.Length > 50)
            text = text.Substring(0, 50);
        var textBytes = Encoding.UTF8.GetBytes(text);
        byte textLen = (byte)textBytes.Length;
        // 有效载荷长度 = TextLen(1) + Text(N) + Checksum(1)
        ushort totalLen = (ushort)(1 + textLen + 1);

        var list = TextHeader.ToList();

        // TotalLen (2 bytes, little-endian)
        list.AddRange(BitConverter.GetBytes(totalLen));

        // TextLen (1 byte)
        list.Add(textLen);

        // Text bytes
        list.AddRange(textBytes);

        // Checksum (1 byte)
        list.Add(byte.Parse(Checksum(textBytes).ToString()));

        return Build(list);
    }

    /// <summary>
    /// 转换布局枚举到对应的 HID 包字节数组
    /// </summary>
    /// <param name="haloPixelTextLayout"></param>
    /// <returns></returns>
    public static byte[] ConvertLayout(HaloPixelTextLayout haloPixelTextLayout) => haloPixelTextLayout switch
    {
        HaloPixelTextLayout.Left => [0x2e, 0xaa, 0xec, 0xef, 0x00, 0x09, 0x01, 0xf0, 0xb4, 0xc8, 0x00, 0x02, 0x00, 0x00, 0xff, 0xfc, 0x00],
        HaloPixelTextLayout.Center => [0x2e, 0xaa, 0xec, 0xef, 0x00, 0x09, 0x01, 0xf0, 0xb4, 0xc8, 0x00, 0x02, 0x00, 0x01, 0xff, 0xfd, 0x00],
        HaloPixelTextLayout.Right => [0x2e, 0xaa, 0xec, 0xef, 0x00, 0x09, 0x01, 0xf0, 0xb4, 0xc8, 0x00, 0x02, 0x00, 0x02, 0xff, 0xfe, 0x00],
        HaloPixelTextLayout.Stretch => [0x2e, 0xaa, 0xec, 0xef, 0x00, 0x09, 0x01, 0xf0, 0xb4, 0xc8, 0x00, 0x02, 0x00, 0x03, 0xff, 0xff, 0x00],
        HaloPixelTextLayout.ScrollLeftToRight => [0x2e, 0xaa, 0xec, 0xef, 0x00, 0x09, 0x01, 0xf0, 0xb4, 0xc8, 0x00, 0x02, 0x01, 0x00, 0xff, 0xfd, 0x00],
        HaloPixelTextLayout.ScrollRightToLeft => [0x2e, 0xaa, 0xec, 0xef, 0x00, 0x09, 0x01, 0xf0, 0xb4, 0xc8, 0x00, 0x02, 0x01, 0x01, 0xff, 0xfe, 0x00],
        _ => [],
    };

    public static byte[] ConvertUIModel(HaloPixelUIModel haloPixelUIModel) => haloPixelUIModel switch
    {
        HaloPixelUIModel.Clock => [0x2e, 0xaa, 0xec, 0xef, 0x00, 0x09, 0x02, 0xf0, 0xb4, 0xc8, 0x00, 0x01, 0x00, 0xff, 0xff, 0xfb, 0x00],
        HaloPixelUIModel.Game => [0x2e, 0xaa, 0xec, 0xef, 0x00, 0x09, 0x02, 0xf0, 0xb4, 0xc8, 0x00, 0x01, 0x01, 0xff, 0xff, 0xfc, 0x00],
        HaloPixelUIModel.Work => [0x2e, 0xaa, 0xec, 0xef, 0x00, 0x09, 0x02, 0xf0, 0xb4, 0xc8, 0x00, 0x01, 0x02, 0xff, 0xff, 0xfd, 0x00],
        HaloPixelUIModel.Read => [0x2e, 0xaa, 0xec, 0xef, 0x00, 0x09, 0x02, 0xf0, 0xb4, 0xc8, 0x00, 0x01, 0x03, 0xff, 0xff, 0xfe, 0x00],
        HaloPixelUIModel.Cats => [0x2e, 0xaa, 0xec, 0xef, 0x00, 0x09, 0x02, 0xf0, 0xb4, 0xc8, 0x00, 0x01, 0x04, 0xff, 0xff, 0xff, 0x00],
        HaloPixelUIModel.Dogs => [0x2e, 0xaa, 0xec, 0xef, 0x00, 0x09, 0x02, 0xf0, 0xb4, 0xc8, 0x00, 0x01, 0x05, 0xff, 0xff, 0x00, 0x00],
        HaloPixelUIModel.Memes => [0x2e, 0xaa, 0xec, 0xef, 0x00, 0x09, 0x02, 0xf0, 0xb4, 0xc8, 0x00, 0x01, 0x06, 0xff, 0xff, 0x01, 0x00],
        HaloPixelUIModel.Cyber => [0x2e, 0xaa, 0xec, 0xef, 0x00, 0x09, 0x02, 0xf0, 0xb4, 0xc8, 0x00, 0x01, 0x07, 0xff, 0xff, 0x02, 0x00],
        HaloPixelUIModel.Waves => [0x2e, 0xaa, 0xec, 0xef, 0x00, 0x09, 0x02, 0xf0, 0xb4, 0xc8, 0x00, 0x01, 0x08, 0xff, 0xff, 0x03, 0x00],
        _ => [],
    };

    /// <summary>
    /// 构造 HID 协议包
    /// </summary>
    public static byte[] Build(byte[] bytes) => Build(bytes.ToList());

    /// <summary>
    /// 构造 HID 协议包
    /// </summary>
    public static byte[] Build(List<byte> bytes)
    {
        // Padding 补 0 到固定长度（64 字节）
        while (bytes.Count < FixedPacketLength)
            bytes.Add(0x00);

        return [.. bytes];
    }

    /// <summary>
    /// 校验算法
    /// </summary>
    public static int Checksum(byte[] textBytes)
    {
        int acc = 128;
        foreach (char ch in textBytes.Select(v => (char)v))
        {
            acc += ch + 2;
        }
        return acc % 256;
    }

    /// <summary>
    /// 把包转成 hex 字符串（小写，不带空格）
    /// </summary>
    public static string ToHex(byte[] packet)
    {
        return BitConverter.ToString(packet).Replace("-", "").ToLower();
    }
}
